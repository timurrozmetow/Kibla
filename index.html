<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Кибла — точное направление на Каабу</title>
  <meta name="theme-color" content="#0b0f14" />
  <style>
    :root{
      --bg:#0b0f14;
      --card:#101826;
      --card2:#0e1522;
      --text:#e8eef7;
      --muted:#9bb0c6;
      --line:rgba(255,255,255,.10);
      --ok:#37d67a;
      --warn:#ffbf3c;
      --bad:#ff5d5d;
      --accent:#53a7ff;
      --shadow: 0 12px 35px rgba(0,0,0,.35);
      color-scheme: dark;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 700px at 50% -10%, rgba(83,167,255,.20), transparent 55%),
                  radial-gradient(900px 600px at 20% 110%, rgba(55,214,122,.14), transparent 60%),
                  var(--bg);
      color:var(--text);
      min-height:100vh;
      padding: 16px;
      display:grid;
      place-items:center;
    }
    .wrap{
      width:min(640px,100%);
      display:grid;
      gap:12px;
    }
    header{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:12px;
      padding: 2px 2px 6px;
    }
    h1{
      margin:0;
      font-size:16px;
      letter-spacing:.2px;
      font-weight:650;
    }
    .sub{
      margin:4px 0 0;
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }
    .chipRow{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    .chip{
      font-size:12px;
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background: rgba(255,255,255,.03);
      color: var(--muted);
      display:flex; align-items:center; gap:8px;
      user-select:none;
    }
    .dot{width:8px;height:8px;border-radius:50%;}
    .dot.ok{background:var(--ok)}
    .dot.warn{background:var(--warn)}
    .dot.bad{background:var(--bad)}

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    @media(min-width: 640px){
      .grid{grid-template-columns: 1.05fr .95fr;}
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .pad{padding:14px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    button, input, select{
      font: inherit;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color: var(--text);
      padding:10px 12px;
      outline: none;
    }
    button{cursor:pointer}
    button.primary{
      border-color: rgba(83,167,255,.6);
      background: linear-gradient(180deg, rgba(83,167,255,.18), rgba(83,167,255,.07));
    }
    button.ghost{
      background: rgba(255,255,255,.02);
    }
    button:active{transform: translateY(1px)}
    .muted{color:var(--muted)}
    .small{font-size:12px; line-height:1.35}
    .kv{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:10px 0;
      border-bottom:1px dashed rgba(255,255,255,.12);
      font-size:14px;
    }
    .kv:last-child{border-bottom:0}
    .kv b{font-weight:700}
    .divider{
      height:1px; background:var(--line);
      margin: 10px -14px;
    }

    /* Compass */
    .compassWrap{
      display:grid;
      place-items:center;
      padding: 12px 12px 6px;
    }
    .compass{
      width: 300px;
      height: 300px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(circle at 50% 50%, rgba(255,255,255,.05), rgba(255,255,255,.01) 60%, rgba(0,0,0,.15) 100%),
        conic-gradient(from 0deg, rgba(83,167,255,.16), rgba(55,214,122,.10), rgba(255,191,60,.10), rgba(83,167,255,.16));
      position: relative;
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
      overflow:hidden;
    }
    @media(max-width: 360px){
      .compass{width: 270px;height:270px;}
    }
    .ring{
      position:absolute; inset:10px;
      border-radius:50%;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      display:grid; place-items:center;
    }
    .ticks{
      position:absolute; inset:0;
      opacity:.7;
      pointer-events:none;
    }
    .label{
      position:absolute; left:50%; top:10px;
      transform: translateX(-50%);
      font-weight:800;
      letter-spacing:.6px;
      opacity:.95;
    }
    .label.s{top:auto; bottom:10px;}
    .label.e{top:50%; left:auto; right:10px; transform: translateY(-50%);}
    .label.w{top:50%; left:10px; transform: translateY(-50%);}

    .needleLayer{
      position:absolute; inset:0;
      display:grid; place-items:center;
      transform: rotate(0deg);
      transition: transform .10s linear;
    }
    .needle{
      width: 14px; height: 120px;
      position: relative;
    }
    .needle:before{
      content:"";
      position:absolute; left:50%; top:0;
      transform:translateX(-50%);
      width:0;height:0;
      border-left:14px solid transparent;
      border-right:14px solid transparent;
      border-bottom: 80px solid rgba(255,255,255,.92);
      filter: drop-shadow(0 8px 14px rgba(0,0,0,.35));
    }
    .needle:after{
      content:"";
      position:absolute; left:50%; bottom:0;
      transform:translateX(-50%);
      width:10px;height:10px;border-radius:50%;
      background: rgba(255,255,255,.25);
      border:1px solid rgba(255,255,255,.22);
      box-shadow: 0 10px 25px rgba(0,0,0,.35);
    }

    .kaabaBadge{
      position:absolute;
      top:12px; left:12px;
      display:flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      font-size:12px;
      color: var(--text);
      backdrop-filter: blur(6px);
    }
    .kaabaIcon{
      width:14px;height:14px;border-radius:3px;
      background: linear-gradient(180deg,#d8b24a,#8b6d22);
      position:relative;
      box-shadow: 0 8px 18px rgba(0,0,0,.35);
    }
    .kaabaIcon:before{
      content:"";
      position:absolute; left:2px; right:2px; top:4px; height:3px;
      background: rgba(0,0,0,.75);
      border-radius:2px;
    }

    .hint{
      padding: 0 14px 12px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
    .warnBox{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,191,60,.35);
      background: rgba(255,191,60,.08);
      color: rgba(255,255,255,.9);
      font-size: 12px;
      line-height: 1.35;
      display:none;
    }
    .manualBox{
      display:none;
      margin-top: 10px;
      gap:10px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .footer{
      text-align:center;
      color: var(--muted);
      font-size: 12px;
      padding: 4px 0 0;
    }
    a{color: var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Кибла</h1>
        <div class="sub">Открой сайт по HTTPS → нажми “Старт”. Держи телефон ровно (горизонтально).</div>
      </div>
      <div class="chipRow">
        <div class="chip"><span class="dot" id="gpsDot"></span><span id="gpsChip">GPS: —</span></div>
        <div class="chip"><span class="dot" id="sensDot"></span><span id="sensChip">Сенсоры: —</span></div>
        <div class="chip"><span class="dot" id="qualDot"></span><span id="qualChip">Качество: —</span></div>
      </div>
    </header>

    <div class="grid">
      <div class="card">
        <div class="compassWrap">
          <div class="compass" id="compass">
            <div class="kaabaBadge"><span class="kaabaIcon"></span>Кааба</div>

            <svg class="ticks" viewBox="0 0 100 100" aria-hidden="true">
              <g opacity="0.55">
                <!-- 36 small ticks -->
                <script type="application/ecmascript"><![CDATA[
                  // (inline SVG script not executed in many CSP contexts; ticks drawn by CSS/JS below)
                ]]></script>
              </g>
            </svg>

            <div class="ring">
              <div class="needleLayer" id="needleLayer">
                <div class="needle"></div>
              </div>
            </div>
          </div>
        </div>
        <div class="hint" id="status">Статус: готово.</div>
      </div>

      <div class="card">
        <div class="pad">
          <div class="row">
            <button class="primary" id="btnStart">Старт (GPS + компас)</button>
            <button class="ghost" id="btnStop">Стоп</button>
          </div>

          <div class="warnBox" id="warnBox"></div>

          <div class="divider"></div>

          <div class="kv"><span class="muted">Азимут Киблы</span><b id="qiblaAz">—</b></div>
          <div class="kv"><span class="muted">Курс телефона</span><b id="heading">—</b></div>
          <div class="kv"><span class="muted">Поворот стрелки</span><b id="turn">—</b></div>
          <div class="kv"><span class="muted">Координаты</span><b id="coords">—</b></div>
          <div class="kv"><span class="muted">Точность GPS</span><b id="acc">—</b></div>

          <div class="divider"></div>

          <div class="small muted">
            Если “прыгает”: убери магнитный чехол/держатель, отойди от металла/машины, сделай “восьмёрку” телефоном 5–10 сек.
            <br/>Если датчики у телефона слабые/помехи сильные — используй ручной режим (координаты).
          </div>
        </div>
      </div>
    </div>

    <div class="footer">
      Веб-версия не может получить доступ к датчикам так же полно, как нативные приложения. Но тут реализован максимально устойчивый режим для браузера.
    </div>
  </div>

<script>
(() => {
  // =========================
  // Core config (tuned for stability)
  // =========================
  const KAABA = { lat: 21.422487, lon: 39.826206 };

  // фильтрация/антишум:
  const CFG = {
    alpha: 0.08,          // сглаживание (меньше = стабильнее)
    maxStepDeg: 10,       // ограничение "скорости" поворота за событие
    rejectJumpDeg: 55,    // если скачок больше — игнор (помеха)
    minEventMs: 40,       // игнор слишком частых событий
    gpsTimeout: 15000,
  };

  // =========================
  // DOM
  // =========================
  const el = (id) => document.getElementById(id);

  const needleLayer = el('needleLayer');
  const statusEl = el('status');
  const warnBox = el('warnBox');

  const qiblaAzEl = el('qiblaAz');
  const headingEl = el('heading');
  const turnEl = el('turn');
  const coordsEl = el('coords');
  const accEl = el('acc');

  const gpsDot = el('gpsDot');
  const sensDot = el('sensDot');
  const qualDot = el('qualDot');
  const gpsChip = el('gpsChip');
  const sensChip = el('sensChip');
  const qualChip = el('qualChip');

  // =========================
  // State
  // =========================
  let userLat = null, userLon = null, gpsAcc = null;
  let qiblaAz = null;
  let headingDeg = null;     // 0..360
  let lastRaw = null;
  let lastEventTs = 0;

  let watchId = null;

  // sensors mode
  // "ABS_SENSOR" (AbsoluteOrientationSensor), "DEV_ORIENT" (DeviceOrientation), "NONE"
  let sensorMode = "NONE";

  // quality
  // OK / WARN / BAD derived from GPS accuracy + stability
  let quality = "WARN";

  // =========================
  // Utils
  // =========================
  const toRad = (d) => d * Math.PI / 180;
  const toDeg = (r) => r * 180 / Math.PI;
  const norm360 = (d) => ((d % 360) + 360) % 360;
  const shortestDelta = (from, to) => ((to - from + 540) % 360) - 180;

  function setStatus(msg) {
    statusEl.textContent = "Статус: " + msg;
  }

  function showWarn(msg) {
    warnBox.style.display = "block";
    warnBox.textContent = msg;
  }
  function hideWarn() {
    warnBox.style.display = "none";
    warnBox.textContent = "";
  }

  function setDot(dotEl, level) {
    dotEl.className = "dot " + (level === "OK" ? "ok" : level === "WARN" ? "warn" : "bad");
  }

  function updateChips() {
    // GPS chip
    if (userLat == null) {
      gpsChip.textContent = "GPS: —";
      setDot(gpsDot, "BAD");
    } else {
      const acc = (gpsAcc == null) ? "?" : Math.round(gpsAcc) + "м";
      gpsChip.textContent = "GPS: " + acc;
      setDot(gpsDot, gpsAcc != null && gpsAcc <= 25 ? "OK" : gpsAcc != null && gpsAcc <= 60 ? "WARN" : "BAD");
    }

    // Sensors chip
    sensChip.textContent = "Сенсоры: " + (sensorMode === "ABS_SENSOR" ? "ABS" : sensorMode === "DEV_ORIENT" ? "ORIENT" : "—");
    setDot(sensDot, sensorMode === "NONE" ? "BAD" : sensorMode === "DEV_ORIENT" ? "WARN" : "OK");

    // Quality chip
    qualChip.textContent = "Качество: " + (quality === "OK" ? "хорошее" : quality === "WARN" ? "среднее" : "плохое");
    setDot(qualDot, quality);
  }

  function getScreenAngle() {
    const so = window.screen?.orientation?.angle;
    if (typeof so === "number") return so;
    const wo = window.orientation;
    if (typeof wo === "number") return wo;
    return 0;
  }

  function smoothAngle(prev, next, alpha) {
    if (prev == null) return next;
    const d = shortestDelta(prev, next);
    return norm360(prev + d * alpha);
  }

  function clampStep(prev, next, maxStep) {
    if (prev == null) return next;
    const d = shortestDelta(prev, next);
    const clipped = Math.max(-maxStep, Math.min(maxStep, d));
    return norm360(prev + clipped);
  }

  function calcQiblaAzimuth(lat, lon) {
    const φ1 = toRad(lat);
    const φ2 = toRad(KAABA.lat);
    const Δλ = toRad(KAABA.lon - lon);
    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
    return norm360(toDeg(Math.atan2(y, x)));
  }

  function render() {
    // compute qibla
    if (userLat != null && userLon != null) {
      qiblaAz = calcQiblaAzimuth(userLat, userLon);
      qiblaAzEl.textContent = qiblaAz.toFixed(1) + "°";
      coordsEl.textContent = userLat.toFixed(6) + ", " + userLon.toFixed(6);
      accEl.textContent = gpsAcc == null ? "—" : (Math.round(gpsAcc) + " м");
    } else {
      qiblaAz = null;
      qiblaAzEl.textContent = "—";
      coordsEl.textContent = "—";
      accEl.textContent = "—";
    }

    headingEl.textContent = headingDeg == null ? "—" : norm360(headingDeg).toFixed(1) + "°";

    if (qiblaAz != null) {
      const rotate = (headingDeg == null) ? qiblaAz : norm360(qiblaAz - headingDeg);
      needleLayer.style.transform = `rotate(${rotate}deg)`;
      turnEl.textContent = rotate.toFixed(1) + "°";
    } else {
      needleLayer.style.transform = `rotate(0deg)`;
      turnEl.textContent = "—";
    }

    // update quality heuristics:
    // BAD if no GPS or very bad accuracy or huge sensor jumps
    if (userLat == null) quality = "BAD";
    else if (gpsAcc != null && gpsAcc > 80) quality = "BAD";
    else if (sensorMode === "NONE") quality = "WARN";
    else if (gpsAcc != null && gpsAcc <= 25) quality = "OK";
    else quality = "WARN";

    updateChips();
  }

  // =========================
  // GPS
  // =========================
  function stopGPS() {
    if (watchId != null) {
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
    }
  }

  function startGPSWatch() {
    if (!navigator.geolocation) {
      setStatus("геолокация недоступна в браузере.");
      showWarn("Этот браузер не поддерживает геолокацию.");
      return false;
    }
    hideWarn();

    // watchPosition лучше, чем getCurrentPosition — обновляет точность/координаты
    watchId = navigator.geolocation.watchPosition(
      (pos) => {
        userLat = pos.coords.latitude;
        userLon = pos.coords.longitude;
        gpsAcc = pos.coords.accuracy;
        render();
      },
      (err) => {
        setStatus("ошибка GPS: " + (err.message || err.code));
        showWarn("GPS не дал координаты. Проверь разрешения и включи точную геолокацию.");
        render();
      },
      { enableHighAccuracy: true, timeout: CFG.gpsTimeout, maximumAge: 1500 }
    );
    return true;
  }

  // =========================
  // Best sensor: AbsoluteOrientationSensor if available
  // =========================
  let absSensor = null;

  function quatToHeadingDeg(q) {
    // q = [x,y,z,w]
    const x = q[0], y = q[1], z = q[2], w = q[3];
    // yaw (Z) in radians
    const siny_cosp = 2 * (w * z + x * y);
    const cosy_cosp = 1 - 2 * (y * y + z * z);
    let yaw = Math.atan2(siny_cosp, cosy_cosp); // -pi..pi
    let heading = norm360(360 - toDeg(yaw)); // convert to compass-like
    heading = norm360(heading + getScreenAngle());
    return heading;
  }

  function stopSensors() {
    window.removeEventListener("deviceorientationabsolute", onDeviceOrient, true);
    window.removeEventListener("deviceorientation", onDeviceOrient, true);
    if (absSensor) {
      try { absSensor.stop(); } catch {}
      absSensor = null;
    }
    sensorMode = "NONE";
    headingDeg = null;
    lastRaw = null;
    lastEventTs = 0;
    render();
  }

  function startAbsoluteSensor() {
    // Generic Sensor API (не у всех!)
    if (!("AbsoluteOrientationSensor" in window)) return false;

    try {
      absSensor = new AbsoluteOrientationSensor({ frequency: 30, referenceFrame: "screen" });
      absSensor.addEventListener("reading", () => {
        const q = absSensor.quaternion;
        if (!q) return;
        const now = performance.now();
        if (now - lastEventTs < CFG.minEventMs) return;
        lastEventTs = now;

        const raw = norm360(quatToHeadingDeg(q));

        // анти-скачок
        if (lastRaw != null) {
          const jump = Math.abs(shortestDelta(lastRaw, raw));
          if (jump > CFG.rejectJumpDeg) return;
        }
        lastRaw = raw;

        const limited = clampStep(headingDeg, raw, CFG.maxStepDeg);
        headingDeg = smoothAngle(headingDeg, limited, CFG.alpha);
        sensorMode = "ABS_SENSOR";
        render();
      });

      absSensor.addEventListener("error", (e) => {
        // If permissions denied or not allowed
        setStatus("сенсор ABS недоступен — переключаюсь на ориентацию.");
        try { absSensor.stop(); } catch {}
        absSensor = null;
        startDeviceOrientation();
      });

      absSensor.start();
      sensorMode = "ABS_SENSOR";
      setStatus("сенсоры: ABS (лучший режим).");
      return true;
    } catch (e) {
      absSensor = null;
      return false;
    }
  }

  // =========================
  // Fallback: DeviceOrientation (most compatible)
  // =========================
  function onDeviceOrient(event) {
    const now = performance.now();
    if (now - lastEventTs < CFG.minEventMs) return;
    lastEventTs = now;

    let raw = null;

    // iOS safari gives webkitCompassHeading
    if (typeof event.webkitCompassHeading === "number") {
      raw = event.webkitCompassHeading;
    } else if (typeof event.alpha === "number") {
      // On Android Chrome: heading is usually 360 - alpha
      raw = 360 - event.alpha;
      raw = raw + getScreenAngle();
    } else {
      return;
    }

    raw = norm360(raw);

    // anti-jump (magnetic noise)
    if (lastRaw != null) {
      const jump = Math.abs(shortestDelta(lastRaw, raw));
      if (jump > CFG.rejectJumpDeg) return;
    }
    lastRaw = raw;

    const limited = clampStep(headingDeg, raw, CFG.maxStepDeg);
    headingDeg = smoothAngle(headingDeg, limited, CFG.alpha);

    sensorMode = "DEV_ORIENT";
    render();
  }

  async function startDeviceOrientation() {
    const DO = window.DeviceOrientationEvent;
    if (!DO) return false;

    // iOS permission
    if (typeof DO.requestPermission === "function") {
      try {
        const res = await DO.requestPermission();
        if (res !== "granted") {
          setStatus("нет доступа к компасу.");
          showWarn("Нужен доступ к датчикам. Разреши Motion/Orientation и обнови страницу.");
          return false;
        }
      } catch {
        setStatus("не удалось запросить доступ к компасу.");
        return false;
      }
    }

    window.removeEventListener("deviceorientationabsolute", onDeviceOrient, true);
    window.removeEventListener("deviceorientation", onDeviceOrient, true);
    window.addEventListener("deviceorientationabsolute", onDeviceOrient, true);
    window.addEventListener("deviceorientation", onDeviceOrient, true);

    sensorMode = "DEV_ORIENT";
    setStatus("сенсоры: DeviceOrientation (совместимый режим).");
    return true;
  }

  // =========================
  // UX actions
  // =========================
  function canRunSecure() {
    // Geolocation + motion usually require HTTPS
    return location.protocol === "https:" || location.hostname === "localhost";
  }

  async function startAll() {
    hideWarn();
    if (!canRunSecure()) {
      setStatus("нужен HTTPS.");
      showWarn("Открой сайт по HTTPS. Иначе GPS/сенсоры могут быть заблокированы.");
      return;
    }

    setStatus("запрашиваю разрешения…");

    // Start GPS watch
    startGPSWatch();

    // Start sensors: try best first
    stopSensors();
    const okAbs = startAbsoluteSensor();
    if (!okAbs) {
      const okDO = await startDeviceOrientation();
      if (!okDO) {
        sensorMode = "NONE";
          showWarn("Компас недоступен в этом браузере. Проверь разрешения, HTTPS и попробуй другой браузер (Chrome/Safari).");
      }
    }

    setStatus("готово. Держи телефон горизонтально.");
    render();
  }

  function stopAll() {
    stopGPS();
    stopSensors();
    setStatus("остановлено.");
    render();
  }

  el("btnStart").addEventListener("click", startAll);
  el("btnStop").addEventListener("click", stopAll);

  // =========================
  // Initial render
  // =========================
  setStatus("готово. Нажми “Старт”.");
  render();
})();
</script>
</body>
</html>
